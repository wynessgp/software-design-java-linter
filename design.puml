@startuml
package presentation {
    +class Main {
        +{static} main(args: String[]): void
    }
    +interface UserInterface {
        +display(): void
    }
    +interface UserInput {
        +getNextLine(): String
    }
    +class ConsoleUserInterface implements UserInterface {
        -args: String[]
        -userInput: UserInput
        -projectDirectory: File
        -reader: StandardInput
        -writer: StandardOutput
        -runner: LintRunner
        +ConsoleUserInterface(args: String[])
        +display(): void
        -promptForWorkingDirectory(): void
        -displayDetectedFiles(): void
        -promptForCheckOptions(): void
        -runChecks(): void
        -promptForSavingResults(): void
        -saveResults(): void
        -promptForCodeCleanup(): void
        -promptForUmlGeneration(): void
        -promptForSkeletonCodeGeneration(): void
    }
    +class ConsoleScanner implements UserInput {
        -scanner: Scanner
        +getNextLine(): String
    }

    Main .> UserInterface
    ConsoleUserInterface -> UserInput
}
ConsoleUserInterface -> domain.LintRunner
ConsoleUserInterface -d-> "*" datasource.StandardInput
ConsoleUserInterface -d-> "*" datasource.StandardOutput

package domain {
    +class LintRunner {
        -checks: List<CheckStrategy>
        -readers: List<ClassReader>
        +LintRunner(classNames: List<String>)
        -createClassReaders(): void
        +addCheck(check: CheckStrategy): void
        +runChecks(): Map<String, List<String>>
    }
    LintRunner -d-> "*" CheckStrategy
    LintRunner -> "*" ClassReader

    +interface ClassReader {
        +acceptClass(classPath: String): boolean
        +getClassNode(): ClassNode
    }
    +interface ClassNode {
        +matchesAccess(access: String): boolean
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
    }
    +interface FieldNode {
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
    }
    +interface MethodNode {
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): List<InstructionNode>
        +getReturnType(): String
        +getArgs(): Map<String, String>
    }
    +interface InstructionNode {
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
    }
    +interface MethodInstructionNode {
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDesc(): String
    }
    +interface FieldInstructionNode {
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDesc(): String
    }

    MethodInstructionNode -u-|> InstructionNode
    FieldInstructionNode -u-|> InstructionNode
    ClassNode .d.> FieldNode
    ClassNode .d.> MethodNode
    InstructionNode ..> InstructionNode
    MethodNode .d.> InstructionNode

    +class ClassReaderASM {
        -classReader: ClassReader
        -classNode: ClassNode
        +acceptClass(classPath: String): boolean
        +getClassNode(): ClassNode
    }
    +class ClassNodeASM {
        -classNode: ClassNode
        +ClassNodeASM()
        +matchesAccess(access: String): boolean
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
    }
    +class MethodNodeASM {
        -methodNode: MethodNode
        +MethodNodeASM(mn: MethodNode)
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): List<InstructionNode>
        +getReturnType(): String
        +getArgs(): Map<String, String>
    }
    +class FieldNodeASM {
        -fieldNode: FieldNode
        +FieldNodeASM(fn: FieldNode)
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
    }
    +class InstructionNodeASM {
        -instructionNode: AbstractInsnNode
        +InstructionNodeASM(in: AbstractInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
    }
    +class MethodInstructionNodeASM {
        -instructionNode: MethodInsnNode
        +MethodInstructionNodeASM(min: MethodInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDescription(): String
    }
    +class FieldInstructionNodeASM {
        -instructionNode: FieldInsnNode
        +FieldInstructionNodeASM(fin: FieldInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDescription(): String
    }

    ClassReaderASM .u.|> ClassReader
    ClassNodeASM .u.|> ClassNode
    MethodNodeASM .u.|> MethodNode
    FieldNodeASM .u.|> FieldNode
    InstructionNodeASM .u.|> InstructionNode
    MethodInstructionNodeASM .u.|> MethodInstructionNode
    FieldInstructionNodeASM .u.|> FieldInstructionNode
    MethodNodeASM .l.> InstructionNode
    ClassReaderASM -> ClassNode

    +interface CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class StaticMethodCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class FormattingCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class UnusedItemsCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class InformationHidingCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class ThreeLayerCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class HollywoodCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class FacadeCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class StrategyCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class DecoratorCheck implements CheckStrategy {
        -abstractDecorators: Set<String>
        -concreteDecorators: Set<String>
        -abstractComponents: Set<String>
        -concreteComponents: Set<String>
        -outsideClasses: Set<String>
        -interfaceNameToUnconfirmedConcreteComponents: Map<String, Set<String>>
        -interfaceNameToUnconfirmedAbstractDecorators: Map<String, Set<String>>
        -abstractDecoNameToUnconfirmedConcreteDecorators: Map<String, Set<String>>
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
        -singleClassCheck(class: String): void
        -abstractComponentCheck(cn: ClassNode): boolean
        -abstractDecoratorCheck(cn: ClassNode): boolean
        -concreteComponentCheck(cn: ClassNode): boolean
        -concreteDecoratorCheck(cn: ClassNode): boolean
    }
    CheckStrategy .> ClassNode
}
package datasource {
    +interface StandardOutput {
        +write(): void
    }
    +class FileOutput {
        -filepath: String
        -bufferedWriter: BufferedWriter
        +FileOutput(fp: String)
        {method} // interface methods...
    }
    +interface StandardInput {
        +nextLine(): String
        +hasNext(): boolean
        +nextInt(): int
        +next(): String
    }

    +class RecursiveDiver {
        -iter: Iterator<String>
        +RecursiveDiver(path: File)
        -findClassFiles(path: File): Set<String>
        {method} // interface methods
    }

    +class FileReader {
        +FileReader(path: File)
    }

    FileOutput .u.|> StandardOutput
    RecursiveDiver .u.|> StandardInput
    ClassReaderASM .> FileReader
}

package asm {
    package tree {
        +class asm.tree.ClassNode {
        }
        +class asm.tree.MethodNode {
        }
        +class asm.tree.FieldNode {
        }
        +class asm.tree.AbstractInsnNode {
        }
        +class asm.tree.FieldInsnNode {
        }
        +class asm.tree.MethodInsnNode {
        }

        asm.tree.MethodInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.FieldInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.ClassNode -d-> "*" asm.tree.FieldNode
        asm.tree.ClassNode -d-> "*" asm.tree.MethodNode
        asm.tree.MethodNode -d-> "*" asm.tree.AbstractInsnNode
    }
}

domain.ClassNodeASM --> asm.tree.ClassNode
domain.FieldNodeASM --> asm.tree.FieldNode
domain.MethodNodeASM --> asm.tree.MethodNode
domain.ClassReaderASM -> asm.ClassReader
domain.InstructionNodeASM --> asm.tree.AbstractInsnNode
domain.MethodInstructionNodeASM --> asm.tree.MethodInsnNode
domain.FieldInstructionNodeASM --> asm.tree.FieldInsnNode
@enduml
