@startuml
package presentation {
    +class Main {
        +{static} main(args: String[]): void
    }
    Main .> UserInterface

    +interface UserInterface {
        +display(): void
    }
    +interface UserInput {
        +getNextLine(): String
    }
    +class ConsoleUserInterface implements UserInterface {
        -args: String[]
        -userInput: UserInput
        -projectDirectory: File
        -reader: StandardInput
        -writer: StandardOutput
        -runner: LintRunner
        +ConsoleUserInterface(args: String[])
        +display(): void
        -promptForWorkingDirectory(): void
        -displayDetectedFiles(): void
        -promptForCheckOptions(): void
        -runChecks(): void
        -promptForSavingResults(): void
        -saveResults(): void
        -promptForCodeCleanup(): void
        -promptForUmlGeneration(): void
        -promptForSkeletonCodeGeneration(): void
    }
    ConsoleUserInterface -> UserInput

    +class ConsoleScanner implements UserInput {
        -scanner: Scanner
        +ConsoleScanner()
        +getNextLine(): String
    }
}
ConsoleUserInterface -> domain.LintRunner
ConsoleUserInterface .> domain.CheckStrategy
ConsoleUserInterface -d-> "*" datasource.StandardInput
ConsoleUserInterface -d-> "*" datasource.StandardOutput

package domain {
    +class LintRunner {
        - {static} checkTypes: CheckStrategy[]
        -checks: List<CheckStrategy>
        -readers: List<ClassReader>
        +LintRunner()
        +createClassReaders(classNames: List<String>): List<String>
        +addCheck(check: CheckStrategy): void
        +runChecks(): Map<String, List<String>>
        +getCheckTypes(): Map<String, Object>
        +isChecksEmpty(): boolean
    }
    LintRunner -d-> "*" CheckStrategy
    LintRunner -> "*" ClassReader

    +interface ClassReader {
        +acceptClass(className: String): boolean
        +getClassNode(): ClassNode
    }
    +interface ClassNode {
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
        +matchesAccess(access: String): boolean
    }
    ClassNode .d.> FieldNode
    ClassNode .d.> MethodNode

    +interface FieldNode {
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
        +matchesAccess(access: String): boolean
    }
    +interface MethodNode {
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): List<InstructionNode>
        +getReturnType(): String
        +getArgs(): Map<String, String>
        +getArgTypes(): List<String>
    }
    MethodNode .d.> InstructionNode

    +interface InstructionNode {
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +toMethodInstruction(): MethodInstructionNode
        +toFieldInstruction(): FieldInstructionNode
        +toVarInstruction(): VarInstructionNode
    }
    InstructionNode .> MethodInstructionNode
    InstructionNode .> FieldInstructionNode
    InstructionNode .> VarInstructionNode

    +interface MethodInstructionNode extends InstructionNode {
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDesc(): String
    }
    +interface FieldInstructionNode extends InstructionNode {
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDesc(): String
    }
    +interface VarInstructionNode extends InstructionNode {
        +getVarIndex(): int
    }

    +class ClassReaderASM implements ClassReader {
        -classReader: ClassReader
        -classNode: ClassNode
        +acceptClass(classPath: String): boolean
        +getClassNode(): ClassNode
    }
    ClassReaderASM -> ClassNode

    +class ClassNodeASM implements ClassNode {
        -classNode: ClassNode
        +ClassNodeASM()
        +matchesAccess(access: String): boolean
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
        +getAsmNode(): ClassNode
    }
    +class MethodNodeASM implements MethodNode {
        -methodNode: MethodNode
        +MethodNodeASM(methodNode: MethodNode)
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): List<InstructionNode>
        +getReturnType(): String
        +getArgs(): Map<String, String>
        +getArgTypes(): List<String>
    }
    MethodNodeASM .l.> InstructionNode

    +class FieldNodeASM implements FieldNode {
        -fieldNode: FieldNode
        +FieldNodeASM(fieldNode: FieldNode)
        +matchesAccess(access: String): boolean
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
    }
    +class InstructionNodeASM implements InstructionNode {
        #instructionNode: AbstractInsnNode
        +InstructionNodeASM(instructionNode: AbstractInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +toMethodInstruction(): MethodInstructionNode
        +toFieldInstruction(): FieldInstructionNode
        +toVarInstruction(): VarInstructionNode
    }
    +class MethodInstructionNodeASM extends InstructionNodeASM {
        -methodInstructionNode: MethodInsnNode
        +MethodInstructionNodeASM(insnNode: InstructionNode)
        +MethodInstructionNodeASM(instructionNode: MethodInsnNode)
        +matchesInstructionType(type: String): boolean
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDescription(): String
    }
    MethodInstructionNodeASM .u.|> MethodInstructionNode

    +class FieldInstructionNodeASM extends InstructionNodeASM {
        -fieldInstructionNode: FieldInsnNode
        +FieldInstructionNodeASM(insnNode: InstructionNode)
        +FieldInstructionNodeASM(fin: FieldInsnNode)
        +matchesInstructionType(type: String): boolean
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDescription(): String
    }
    FieldInstructionNodeASM .u.|> FieldInstructionNode

    +class VarInstructionNodeASM extends InstructionNodeASM {
        -varInstructionNode: VarInsnNode
        +VarInstructionNodeASM(insnNode: InstructionNode)
        +VarInstructionNodeASM(instructionNode: VarInsnNode)
        +matchesInstructionType(type: String): boolean
        +getVarIndex(): int
    }
    VarInstructionNodeASM .u.|> VarInstructionNode

    +interface CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    CheckStrategy .> ClassNode

    +class StaticCheck implements CheckStrategy {
        -visitedClasses: Set<String>
        -nonStaticClasses: Set<String>
        -classDependencies: Map<String, Set<String>>
        +StaticCheck()
        +performCheck(classes: List<ClassNode>): void
        -parseFields(classNode: ClassNode): void
        -parseMethods(classNode: ClassNode): void
        -parseInstructions(classNode: ClassNode, methodNode: MethodNode): void
        -addDeclaredVariable(dependant: String, dependency: String): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    StaticCheck .> ClassNode
    StaticCheck .> FieldNode
    StaticCheck .> MethodNode
    StaticCheck .> InstructionNode
    StaticCheck .> MethodInstructionNode

    +class FormattingCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class UnusedItemsCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class InformationHidingCheck implements CheckStrategy {
        -violations: Set<String[]>
        +InformationHidingCheck()
        +performCheck(classes: List<ClassNode>): void
        -parseFields(classNode: ClassNode): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    InformationHidingCheck .> ClassNode
    InformationHidingCheck .> FieldNode

    +class ThreeLayerCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class HollywoodCheck implements CheckStrategy {
        -classToViolatingCalls: Map<String, Set<String>>
        -analyzedClasses: Set<String>
        +HollywoodCheck()
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
        -parseInstructionsForViolation(cn: ClassNode): void
    }
    HollywoodCheck .> ClassNode
    HollywoodCheck .> MethodNode
    HollywoodCheck .> InstructionNode

    +class FacadeCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class StrategyCheck implements CheckStrategy {
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
    }
    +class DecoratorCheck implements CheckStrategy {
        -abstractDecorators: Set<String>
        -concreteDecorators: Set<String>
        -abstractComponents: Set<String>
        -concreteComponents: Set<String>
        -outsideClasses: Set<String>
        -interfaceNameToUnconfirmedConcreteComponents: Map<String, Set<String>>
        -interfaceNameToUnconfirmedAbstractDecorators: Map<String, Set<String>>
        -abstractDecoNameToUnconfirmedConcreteDecorators: Map<String, Set<String>>
        +DecoratorCheck()
        +performCheck(classes: List<ClassNode>): void
        +handleResults(): List<String>
        +getCheckName(): String
        -singleClassCheck(cn: ClassNode): void
        -abstractComponentCheck(cn: ClassNode): boolean
        -abstractDecoratorCheck(cn: ClassNode): boolean
        -concreteComponentCheck(cn: ClassNode): boolean
        -concreteDecoratorCheck(cn: ClassNode): boolean
    }
    DecoratorCheck .> ClassNode
    DecoratorCheck .> FieldNode
}

package datasource {
    +interface StandardOutput {
        +write(s: String, off: int, len: int): void
        +write(c: int): void
    }
    +class FileOutput implements StandardOutput {
        -bufferedWriter: BufferedWriter
        +FileOutput(fp: String)
        +write(s: String, off: int, len: int): void
        +write(c: int): void
    }
    +interface StandardInput {
        +nextLine(): String
        +hasNext(): boolean
        +nextInt(): int
        +next(): String
    }
    +class RecursiveDiver implements StandardInput {
        -iter: Iterator<String>
        +RecursiveDiver(path: File)
        -findClassFiles(path: File): Set<String>
        +nextLine(): String
        +hasNext(): boolean
        +nextInt(): int
        +next(): String
    }
    +class FileReader {
        +FileReader(path: File)
    }
    ClassReaderASM .> FileReader
}

package asm {
    package tree {
        asm.tree.MethodInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.FieldInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.VarInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.ClassNode -d-> "*" asm.tree.FieldNode
        asm.tree.ClassNode -d-> "*" asm.tree.MethodNode
        asm.tree.MethodNode -d-> "*" asm.tree.AbstractInsnNode
    }
}

domain.ClassReaderASM -> asm.ClassReader
domain.ClassNodeASM -> asm.tree.ClassNode
domain.ClassNodeASM -> asm.Opcodes
domain.MethodNodeASM -> asm.tree.MethodNode
domain.MethodNodeASM -> asm.Opcodes
domain.MethodNodeASM -> asm.Type
domain.MethodNodeASM -> asm.tree.AbstractInsnNode
domain.MethodNodeASM -> asm.tree.LocalVariableNode
domain.FieldNodeASM -> asm.tree.FieldNode
domain.FieldNodeASM -> asm.Opcodes
domain.FieldNodeASM -> asm.Type
domain.InstructionNodeASM -> asm.tree.AbstractInsnNode
domain.MethodInstructionNodeASM -> asm.tree.MethodInsnNode
domain.FieldInstructionNodeASM -> asm.tree.FieldInsnNode
domain.VarInstructionNodeASM -> asm.tree.VarInsnNode
@enduml
