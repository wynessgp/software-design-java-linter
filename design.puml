@startuml
package presentation {
    +class Main {
        +{static} main(args: String[]): void
    }
    +interface UserInterface {
        +display(): void
    }
    +interface UserInput {
        +getNextLine(): String
    }
    +class ConsoleUserInterface implements UserInterface {
        -userInput: UserInput
        -projectDirectory: File
        -checksToRun: List<CheckStrategy>
        -reader: StandardInput
        -writer: StandardOutput
        +display(): void
        -promptForWorkingDirectory(): void
        -displayDetectedFiles(): void
        -promptForCheckOptions(): void
        -displayCheckResults(): void
        -promptForSavingResults(): void
        -saveResults(): void
        -promptForCodeCleanup(): void
        -promptForUmlGeneration(): void
        -promptForSkeletonCodeGeneration(): void
    }
    +class ConsoleScanner implements UserInput {
        -scanner: Scanner
        +getNextLine(): String
    }

    Main .> UserInterface
    ConsoleUserInterface -> UserInput
}
ConsoleUserInterface -> "*" domain.CheckStrategy
ConsoleUserInterface -> "*" datasource.StandardInput
ConsoleUserInterface -> "*" datasource.StandardOutput

package domain {
    +interface ClassNode {
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
    }
    +interface FieldNode {
        +getAccess(): String
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
    }
    +interface MethodNode {
        +getAccess(): String
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): InstructionNode
        +getReturnType(): String
        +getArgs(): Map<String, String>
    }
    +interface InstructionNode {
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
    }
    +interface MethodInstructionNode {
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDesc(): String
    }
    +interface FieldInstructionNode {
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDesc(): String
    }

    MethodInstructionNode -u-|> InstructionNode
    FieldInstructionNode -u-|> InstructionNode
    ClassNode .d.> FieldNode
    ClassNode .d.> MethodNode
    InstructionNode ..> InstructionNode
    MethodNode .d.> InstructionNode

    +class ClassNodeASM {
        -classNode: ClassNode
        +ClassNodeASM(cn: ClassNode)
        +getFields(): List<FieldNode>
        +getMethods(): List<MethodNode>
        +getInterfaces(): List<String>
        +getSuperName(): String
        +getClassName(): String
    }
    +class MethodNodeASM {
        -methodNode: MethodNode
        +MethodNodeASM(mn: MethodNode)
        +getAccess(): String
        +getDesc(): String
        +getMethodName(): String
        +getInstructions(): InstructionNode
        +getReturnType(): String
        +getArgs(): Map<String, String>
    }
    +class FieldNodeASM {
        -fieldNode: FieldNode
        +FieldNodeASM(fn: FieldNode)
        +getAccess(): String
        +getDesc(): String
        +getFieldName(): String
        +getFieldValue(): Object
        +getFieldType(): String
    }
    +class InstructionNodeASM {
        -instructionNode: AbstractInsnNode
        +InstructionNodeASM(in: AbstractInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
    }
    +class MethodInstructionNodeASM {
        -instructionNode: MethodInsnNode
        +MethodInstructionNodeASM(min: MethodInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +getMethodName(): String
        +getMethodOwner(): String
        +getMethodDescription(): String
    }
    +class FieldInstructionNodeASM {
        -instructionNode: FieldInsnNode
        +FieldInstructionNodeASM(fin: FieldInsnNode)
        +matchesInstructionType(type: String): boolean
        +getOpcode(): int
        +getNextInstruction(): InstructionNode
        +getPreviousInstruction(): InstructionNode
        +getFieldName(): String
        +getFieldOwner(): String
        +getFieldDescription(): String
    }

    ClassNodeASM .u.|> ClassNode
    MethodNodeASM .u.|> MethodNode
    FieldNodeASM .u.|> FieldNode
    InstructionNodeASM .u.|> InstructionNode
    MethodInstructionNodeASM .u.|> MethodInstructionNode
    FieldInstructionNodeASM .u.|> FieldInstructionNode

    +interface CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class StaticMethodCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class FormattingCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class UnusedItemsCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class InformationHidingCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class ThreeLayerCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class HollywoodCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class FacadeCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class StrategyCheck implements CheckStrategy {
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
    }
    +class DecoratorCheck implements CheckStrategy {
        -abstractDecorators: Set<String>
        -concreteDecorators: Set<String>
        -abstractComponents: Set<String>
        -concreteComponents: Set<String>
        -outsideClasses: Set<String>
        -interfaceNameToUnconfirmedConcreteComponents: Map<String, Set<String>>
        -interfaceNameToUnconfirmedAbstractDecorators: Map<String, Set<String>>
        -abstractDecoNameToUnconfirmedConcreteDecorators: Map<String, Set<String>>
        +performCheck(classes: List<String>): void
        +handleResults(preferences: Properties): List<String>
        -singleClassCheck(class: String): void
        -abstractComponentCheck(cn: ClassNode): boolean
        -abstractDecoratorCheck(cn: ClassNode): boolean
        -concreteComponentCheck(cn: ClassNode): boolean
        -concreteDecoratorCheck(cn: ClassNode): boolean
    }

    domain.CheckStrategy .l.> domain.ClassNode
}
package datasource {
    +interface StandardOutput {
        +write(): void
    }
    +class FileOutput {
        -filepath: String
        -bufferedWriter: BufferedWriter
        +ConsoleOutput(fp: String)
        {method} // interface methods...
    }
    +interface StandardInput {
        +nextLine(): String
        +hasNext(): boolean
        +nextInt(): int
        +next(): String
    }
    +class ConsoleInput {
        -scan: Scanner
        -fileStream: FileInputStream
        +ConsoleInput(fs: FileInputStream)
        {method} // interface methods...
    }
    +class RecursiveDiver {
        +RecursiveDiver(dirPath: String)
        {method} // interface methods
        -fetchAllClassFiles(): List<String>
    }

    ConsoleInput .u.|> StandardInput
    FileOutput .u.|> StandardOutput
    RecursiveDiver .u.|> StandardInput
}

package asm {
    package tree {
        +class asm.tree.ClassNode {
        }
        +class asm.tree.MethodNode {
        }
        +class asm.tree.FieldNode {
        }
        +class asm.tree.AbstractInsnNode {
        }
        +class asm.tree.FieldInsnNode {
        }
        +class asm.tree.MethodInsnNode {
        }

        asm.tree.MethodInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.FieldInsnNode -u-|> asm.tree.AbstractInsnNode
        asm.tree.ClassNode -d-> "*" asm.tree.FieldNode
        asm.tree.ClassNode -d-> "*" asm.tree.MethodNode
        asm.tree.MethodNode -d-> "*" asm.tree.AbstractInsnNode
    }
}

domain.ClassNodeASM --> asm.tree.ClassNode
domain.FieldNodeASM --> asm.tree.FieldNode
domain.MethodNodeASM --> asm.tree.MethodNode
domain.InstructionNodeASM --> asm.tree.AbstractInsnNode
domain.MethodInstructionNodeASM --> asm.tree.MethodInsnNode
domain.FieldInstructionNodeASM --> asm.tree.FieldInsnNode
@enduml
